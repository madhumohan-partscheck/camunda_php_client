<?php
/**
 * DeploymentApi
 * PHP version 7.2
 *
 * @category Class
 * @package  StrehleDe\CamundaClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Camunda BPM REST API
 *
 * OpenApi Spec for Camunda BPM REST API.
 *
 * The version of the OpenAPI document: 7.13.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace StrehleDe\CamundaClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use StrehleDe\CamundaClient\ApiException;
use StrehleDe\CamundaClient\Configuration;
use StrehleDe\CamundaClient\HeaderSelector;
use StrehleDe\CamundaClient\ObjectSerializer;

/**
 * DeploymentApi Class Doc Comment
 *
 * @category Class
 * @package  StrehleDe\CamundaClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DeploymentApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createDeployment
     *
     * @param  string $tenant_id The tenant id for the deployment to be created. (optional)
     * @param  string $deployment_source The source for the deployment to be created. (optional)
     * @param  bool $deploy_changed_only A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true. (optional, default to false)
     * @param  bool $enable_duplicate_filtering A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false. (optional, default to false)
     * @param  string $deployment_name The name for the deployment to be created. (optional)
     * @param  \SplFileObject $data The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto|\StrehleDe\CamundaClient\Model\ParseExceptionDto
     */
    public function createDeployment($tenant_id = null, $deployment_source = null, $deploy_changed_only = false, $enable_duplicate_filtering = false, $deployment_name = null, $data = null)
    {
        list($response) = $this->createDeploymentWithHttpInfo($tenant_id, $deployment_source, $deploy_changed_only, $enable_duplicate_filtering, $deployment_name, $data);
        return $response;
    }

    /**
     * Operation createDeploymentWithHttpInfo
     *
     * @param  string $tenant_id The tenant id for the deployment to be created. (optional)
     * @param  string $deployment_source The source for the deployment to be created. (optional)
     * @param  bool $deploy_changed_only A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true. (optional, default to false)
     * @param  bool $enable_duplicate_filtering A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false. (optional, default to false)
     * @param  string $deployment_name The name for the deployment to be created. (optional)
     * @param  \SplFileObject $data The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto|\StrehleDe\CamundaClient\Model\ParseExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function createDeploymentWithHttpInfo($tenant_id = null, $deployment_source = null, $deploy_changed_only = false, $enable_duplicate_filtering = false, $deployment_name = null, $data = null)
    {
        $request = $this->createDeploymentRequest($tenant_id, $deployment_source, $deploy_changed_only, $enable_duplicate_filtering, $deployment_name, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ParseExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ParseExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ParseExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createDeploymentAsync
     *
     * 
     *
     * @param  string $tenant_id The tenant id for the deployment to be created. (optional)
     * @param  string $deployment_source The source for the deployment to be created. (optional)
     * @param  bool $deploy_changed_only A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true. (optional, default to false)
     * @param  bool $enable_duplicate_filtering A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false. (optional, default to false)
     * @param  string $deployment_name The name for the deployment to be created. (optional)
     * @param  \SplFileObject $data The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeploymentAsync($tenant_id = null, $deployment_source = null, $deploy_changed_only = false, $enable_duplicate_filtering = false, $deployment_name = null, $data = null)
    {
        return $this->createDeploymentAsyncWithHttpInfo($tenant_id, $deployment_source, $deploy_changed_only, $enable_duplicate_filtering, $deployment_name, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $tenant_id The tenant id for the deployment to be created. (optional)
     * @param  string $deployment_source The source for the deployment to be created. (optional)
     * @param  bool $deploy_changed_only A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true. (optional, default to false)
     * @param  bool $enable_duplicate_filtering A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false. (optional, default to false)
     * @param  string $deployment_name The name for the deployment to be created. (optional)
     * @param  \SplFileObject $data The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createDeploymentAsyncWithHttpInfo($tenant_id = null, $deployment_source = null, $deploy_changed_only = false, $enable_duplicate_filtering = false, $deployment_name = null, $data = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto';
        $request = $this->createDeploymentRequest($tenant_id, $deployment_source, $deploy_changed_only, $enable_duplicate_filtering, $deployment_name, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createDeployment'
     *
     * @param  string $tenant_id The tenant id for the deployment to be created. (optional)
     * @param  string $deployment_source The source for the deployment to be created. (optional)
     * @param  bool $deploy_changed_only A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true. (optional, default to false)
     * @param  bool $enable_duplicate_filtering A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false. (optional, default to false)
     * @param  string $deployment_name The name for the deployment to be created. (optional)
     * @param  \SplFileObject $data The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createDeploymentRequest($tenant_id = null, $deployment_source = null, $deploy_changed_only = false, $enable_duplicate_filtering = false, $deployment_name = null, $data = null)
    {

        $resourcePath = '/deployment/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        if ($tenant_id !== null) {
            $formParams['tenant-id'] = ObjectSerializer::toFormValue($tenant_id);
        }
        // form params
        if ($deployment_source !== null) {
            $formParams['deployment-source'] = ObjectSerializer::toFormValue($deployment_source);
        }
        // form params
        if ($deploy_changed_only !== null) {
            $formParams['deploy-changed-only'] = ObjectSerializer::toFormValue($deploy_changed_only);
        }
        // form params
        if ($enable_duplicate_filtering !== null) {
            $formParams['enable-duplicate-filtering'] = ObjectSerializer::toFormValue($enable_duplicate_filtering);
        }
        // form params
        if ($deployment_name !== null) {
            $formParams['deployment-name'] = ObjectSerializer::toFormValue($deployment_name);
        }
        // form params
        if ($data !== null) {
            $multipart = true;
            $formParams['data'] = [];
            $paramFiles = is_array($data) ? $data : [$data];
            foreach ($paramFiles as $paramFile) {
                $formParams['data'][] = \GuzzleHttp\Psr7\try_fopen(
                    ObjectSerializer::toFormValue($paramFile),
                    'rb'
                );
            }
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDeployment
     *
     * @param  string $id The id of the deployment to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted. (optional, default to false)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings &#x60;true&#x60;, if all input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDeployment($id, $cascade = false, $skip_custom_listeners = false, $skip_io_mappings = false)
    {
        $this->deleteDeploymentWithHttpInfo($id, $cascade, $skip_custom_listeners, $skip_io_mappings);
    }

    /**
     * Operation deleteDeploymentWithHttpInfo
     *
     * @param  string $id The id of the deployment to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted. (optional, default to false)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings &#x60;true&#x60;, if all input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDeploymentWithHttpInfo($id, $cascade = false, $skip_custom_listeners = false, $skip_io_mappings = false)
    {
        $request = $this->deleteDeploymentRequest($id, $cascade, $skip_custom_listeners, $skip_io_mappings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDeploymentAsync
     *
     * 
     *
     * @param  string $id The id of the deployment to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted. (optional, default to false)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings &#x60;true&#x60;, if all input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDeploymentAsync($id, $cascade = false, $skip_custom_listeners = false, $skip_io_mappings = false)
    {
        return $this->deleteDeploymentAsyncWithHttpInfo($id, $cascade, $skip_custom_listeners, $skip_io_mappings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the deployment to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted. (optional, default to false)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings &#x60;true&#x60;, if all input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDeploymentAsyncWithHttpInfo($id, $cascade = false, $skip_custom_listeners = false, $skip_io_mappings = false)
    {
        $returnType = '';
        $request = $this->deleteDeploymentRequest($id, $cascade, $skip_custom_listeners, $skip_io_mappings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDeployment'
     *
     * @param  string $id The id of the deployment to be deleted. (required)
     * @param  bool $cascade &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted. (optional, default to false)
     * @param  bool $skip_custom_listeners &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event. (optional, default to false)
     * @param  bool $skip_io_mappings &#x60;true&#x60;, if all input/output mappings should not be invoked. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDeploymentRequest($id, $cascade = false, $skip_custom_listeners = false, $skip_io_mappings = false)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteDeployment'
            );
        }

        $resourcePath = '/deployment/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($cascade !== null) {
            if('form' === 'form' && is_array($cascade)) {
                foreach($cascade as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['cascade'] = $cascade;
            }
        }
        // query params
        if ($skip_custom_listeners !== null) {
            if('form' === 'form' && is_array($skip_custom_listeners)) {
                foreach($skip_custom_listeners as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['skipCustomListeners'] = $skip_custom_listeners;
            }
        }
        // query params
        if ($skip_io_mappings !== null) {
            if('form' === 'form' && is_array($skip_io_mappings)) {
                foreach($skip_io_mappings as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['skipIoMappings'] = $skip_io_mappings;
            }
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployment
     *
     * @param  string $id The id of the deployment. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\DeploymentDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeployment($id)
    {
        list($response) = $this->getDeploymentWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDeploymentWithHttpInfo
     *
     * @param  string $id The id of the deployment. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\DeploymentDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeploymentWithHttpInfo($id)
    {
        $request = $this->getDeploymentRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\DeploymentDto[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\DeploymentDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\DeploymentDto[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\DeploymentDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeploymentAsync
     *
     * 
     *
     * @param  string $id The id of the deployment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentAsync($id)
    {
        return $this->getDeploymentAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeploymentAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the deployment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentAsyncWithHttpInfo($id)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\DeploymentDto[]';
        $request = $this->getDeploymentRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployment'
     *
     * @param  string $id The id of the deployment. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeploymentRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeployment'
            );
        }

        $resourcePath = '/deployment/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeploymentResource
     *
     * @param  string $id The id of the deployment (required)
     * @param  string $resource_id The id of the deployment resource (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\DeploymentResourceDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeploymentResource($id, $resource_id)
    {
        list($response) = $this->getDeploymentResourceWithHttpInfo($id, $resource_id);
        return $response;
    }

    /**
     * Operation getDeploymentResourceWithHttpInfo
     *
     * @param  string $id The id of the deployment (required)
     * @param  string $resource_id The id of the deployment resource (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\DeploymentResourceDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeploymentResourceWithHttpInfo($id, $resource_id)
    {
        $request = $this->getDeploymentResourceRequest($id, $resource_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\DeploymentResourceDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\DeploymentResourceDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\DeploymentResourceDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\DeploymentResourceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeploymentResourceAsync
     *
     * 
     *
     * @param  string $id The id of the deployment (required)
     * @param  string $resource_id The id of the deployment resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentResourceAsync($id, $resource_id)
    {
        return $this->getDeploymentResourceAsyncWithHttpInfo($id, $resource_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeploymentResourceAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the deployment (required)
     * @param  string $resource_id The id of the deployment resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentResourceAsyncWithHttpInfo($id, $resource_id)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\DeploymentResourceDto';
        $request = $this->getDeploymentResourceRequest($id, $resource_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeploymentResource'
     *
     * @param  string $id The id of the deployment (required)
     * @param  string $resource_id The id of the deployment resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeploymentResourceRequest($id, $resource_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeploymentResource'
            );
        }
        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling getDeploymentResource'
            );
        }

        $resourcePath = '/deployment/{id}/resources/{resourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceId' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeploymentResourceData
     *
     * @param  string $id The id of the deployment. (required)
     * @param  string $resource_id The id of the deployment resource. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeploymentResourceData($id, $resource_id)
    {
        list($response) = $this->getDeploymentResourceDataWithHttpInfo($id, $resource_id);
        return $response;
    }

    /**
     * Operation getDeploymentResourceDataWithHttpInfo
     *
     * @param  string $id The id of the deployment. (required)
     * @param  string $resource_id The id of the deployment resource. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeploymentResourceDataWithHttpInfo($id, $resource_id)
    {
        $request = $this->getDeploymentResourceDataRequest($id, $resource_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeploymentResourceDataAsync
     *
     * 
     *
     * @param  string $id The id of the deployment. (required)
     * @param  string $resource_id The id of the deployment resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentResourceDataAsync($id, $resource_id)
    {
        return $this->getDeploymentResourceDataAsyncWithHttpInfo($id, $resource_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeploymentResourceDataAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the deployment. (required)
     * @param  string $resource_id The id of the deployment resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentResourceDataAsyncWithHttpInfo($id, $resource_id)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDeploymentResourceDataRequest($id, $resource_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeploymentResourceData'
     *
     * @param  string $id The id of the deployment. (required)
     * @param  string $resource_id The id of the deployment resource. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeploymentResourceDataRequest($id, $resource_id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeploymentResourceData'
            );
        }
        // verify the required parameter 'resource_id' is set
        if ($resource_id === null || (is_array($resource_id) && count($resource_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_id when calling getDeploymentResourceData'
            );
        }

        $resourcePath = '/deployment/{id}/resources/{resourceId}/data';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($resource_id !== null) {
            $resourcePath = str_replace(
                '{' . 'resourceId' . '}',
                ObjectSerializer::toPathValue($resource_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/octet-stream', '*/*', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/octet-stream', '*/*', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeploymentResources
     *
     * @param  string $id The id of the deployment to retrieve the deployment resources for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\DeploymentResourceDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeploymentResources($id)
    {
        list($response) = $this->getDeploymentResourcesWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDeploymentResourcesWithHttpInfo
     *
     * @param  string $id The id of the deployment to retrieve the deployment resources for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\DeploymentResourceDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeploymentResourcesWithHttpInfo($id)
    {
        $request = $this->getDeploymentResourcesRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\DeploymentResourceDto[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\DeploymentResourceDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\DeploymentResourceDto[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\DeploymentResourceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeploymentResourcesAsync
     *
     * 
     *
     * @param  string $id The id of the deployment to retrieve the deployment resources for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentResourcesAsync($id)
    {
        return $this->getDeploymentResourcesAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeploymentResourcesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the deployment to retrieve the deployment resources for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentResourcesAsyncWithHttpInfo($id)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\DeploymentResourceDto[]';
        $request = $this->getDeploymentResourcesRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeploymentResources'
     *
     * @param  string $id The id of the deployment to retrieve the deployment resources for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeploymentResourcesRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeploymentResources'
            );
        }

        $resourcePath = '/deployment/{id}/resources';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployments
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\DeploymentDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeployments($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getDeploymentsWithHttpInfo($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getDeploymentsWithHttpInfo
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\DeploymentDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeploymentsWithHttpInfo($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $request = $this->getDeploymentsRequest($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\DeploymentDto[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\DeploymentDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\DeploymentDto[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\DeploymentDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeploymentsAsync
     *
     * 
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentsAsync($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getDeploymentsAsyncWithHttpInfo($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeploymentsAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentsAsyncWithHttpInfo($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\DeploymentDto[]';
        $request = $this->getDeploymentsRequest($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployments'
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeploymentsRequest($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/deployment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($name_like !== null) {
            if('form' === 'form' && is_array($name_like)) {
                foreach($name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameLike'] = $name_like;
            }
        }
        // query params
        if ($source !== null) {
            if('form' === 'form' && is_array($source)) {
                foreach($source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['source'] = $source;
            }
        }
        // query params
        if ($without_source !== null) {
            if('form' === 'form' && is_array($without_source)) {
                foreach($without_source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutSource'] = $without_source;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($without_tenant_id !== null) {
            if('form' === 'form' && is_array($without_tenant_id)) {
                foreach($without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTenantId'] = $without_tenant_id;
            }
        }
        // query params
        if ($include_deployments_without_tenant_id !== null) {
            if('form' === 'form' && is_array($include_deployments_without_tenant_id)) {
                foreach($include_deployments_without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeDeploymentsWithoutTenantId'] = $include_deployments_without_tenant_id;
            }
        }
        // query params
        if ($after !== null) {
            if('form' === 'form' && is_array($after)) {
                foreach($after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['after'] = $after;
            }
        }
        // query params
        if ($before !== null) {
            if('form' === 'form' && is_array($before)) {
                foreach($before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['before'] = $before;
            }
        }
        // query params
        if ($sort_by !== null) {
            if('form' === 'form' && is_array($sort_by)) {
                foreach($sort_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortBy'] = $sort_by;
            }
        }
        // query params
        if ($sort_order !== null) {
            if('form' === 'form' && is_array($sort_order)) {
                foreach($sort_order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortOrder'] = $sort_order;
            }
        }
        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeploymentsCount
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\CountResultDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeploymentsCount($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null)
    {
        list($response) = $this->getDeploymentsCountWithHttpInfo($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before);
        return $response;
    }

    /**
     * Operation getDeploymentsCountWithHttpInfo
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\CountResultDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeploymentsCountWithHttpInfo($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null)
    {
        $request = $this->getDeploymentsCountRequest($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\CountResultDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\CountResultDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeploymentsCountAsync
     *
     * 
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentsCountAsync($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null)
    {
        return $this->getDeploymentsCountAsyncWithHttpInfo($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeploymentsCountAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeploymentsCountAsyncWithHttpInfo($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\CountResultDto';
        $request = $this->getDeploymentsCountRequest($id, $name, $name_like, $source, $without_source, $tenant_id_in, $without_tenant_id, $include_deployments_without_tenant_id, $after, $before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeploymentsCount'
     *
     * @param  string $id Filter by deployment id (optional)
     * @param  string $name Filter by the deployment name. Exact match. (optional)
     * @param  string $name_like Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;). (optional)
     * @param  string $source Filter by the deployment source. (optional)
     * @param  bool $without_source Filter by the deployment source whereby source is equal to &#x60;null&#x60;. (optional, default to false)
     * @param  string $tenant_id_in Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids. (optional)
     * @param  bool $without_tenant_id Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $include_deployments_without_tenant_id Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  \DateTime $after Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     * @param  \DateTime $before Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeploymentsCountRequest($id = null, $name = null, $name_like = null, $source = null, $without_source = false, $tenant_id_in = null, $without_tenant_id = false, $include_deployments_without_tenant_id = false, $after = null, $before = null)
    {

        $resourcePath = '/deployment/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($id !== null) {
            if('form' === 'form' && is_array($id)) {
                foreach($id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['id'] = $id;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($name_like !== null) {
            if('form' === 'form' && is_array($name_like)) {
                foreach($name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameLike'] = $name_like;
            }
        }
        // query params
        if ($source !== null) {
            if('form' === 'form' && is_array($source)) {
                foreach($source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['source'] = $source;
            }
        }
        // query params
        if ($without_source !== null) {
            if('form' === 'form' && is_array($without_source)) {
                foreach($without_source as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutSource'] = $without_source;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($without_tenant_id !== null) {
            if('form' === 'form' && is_array($without_tenant_id)) {
                foreach($without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTenantId'] = $without_tenant_id;
            }
        }
        // query params
        if ($include_deployments_without_tenant_id !== null) {
            if('form' === 'form' && is_array($include_deployments_without_tenant_id)) {
                foreach($include_deployments_without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeDeploymentsWithoutTenantId'] = $include_deployments_without_tenant_id;
            }
        }
        // query params
        if ($after !== null) {
            if('form' === 'form' && is_array($after)) {
                foreach($after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['after'] = $after;
            }
        }
        // query params
        if ($before !== null) {
            if('form' === 'form' && is_array($before)) {
                foreach($before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['before'] = $before;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation redeploy
     *
     * @param  string $id The id of the deployment to re-deploy. (required)
     * @param  \StrehleDe\CamundaClient\Model\RedeploymentDto $redeployment_dto redeployment_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function redeploy($id, $redeployment_dto = null)
    {
        list($response) = $this->redeployWithHttpInfo($id, $redeployment_dto);
        return $response;
    }

    /**
     * Operation redeployWithHttpInfo
     *
     * @param  string $id The id of the deployment to re-deploy. (required)
     * @param  \StrehleDe\CamundaClient\Model\RedeploymentDto $redeployment_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function redeployWithHttpInfo($id, $redeployment_dto = null)
    {
        $request = $this->redeployRequest($id, $redeployment_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation redeployAsync
     *
     * 
     *
     * @param  string $id The id of the deployment to re-deploy. (required)
     * @param  \StrehleDe\CamundaClient\Model\RedeploymentDto $redeployment_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redeployAsync($id, $redeployment_dto = null)
    {
        return $this->redeployAsyncWithHttpInfo($id, $redeployment_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation redeployAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the deployment to re-deploy. (required)
     * @param  \StrehleDe\CamundaClient\Model\RedeploymentDto $redeployment_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function redeployAsyncWithHttpInfo($id, $redeployment_dto = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\DeploymentWithDefinitionsDto';
        $request = $this->redeployRequest($id, $redeployment_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'redeploy'
     *
     * @param  string $id The id of the deployment to re-deploy. (required)
     * @param  \StrehleDe\CamundaClient\Model\RedeploymentDto $redeployment_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function redeployRequest($id, $redeployment_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling redeploy'
            );
        }

        $resourcePath = '/deployment/{id}/redeploy';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($redeployment_dto)) {
            $_tempBody = $redeployment_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
