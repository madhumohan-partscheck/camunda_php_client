<?php
/**
 * TaskApi
 * PHP version 7.2
 *
 * @category Class
 * @package  StrehleDe\CamundaClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Camunda BPM REST API
 *
 * OpenApi Spec for Camunda BPM REST API.
 *
 * The version of the OpenAPI document: 7.13.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace StrehleDe\CamundaClient\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use StrehleDe\CamundaClient\ApiException;
use StrehleDe\CamundaClient\Configuration;
use StrehleDe\CamundaClient\HeaderSelector;
use StrehleDe\CamundaClient\ObjectSerializer;

/**
 * TaskApi Class Doc Comment
 *
 * @category Class
 * @package  StrehleDe\CamundaClient
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TaskApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $host_index (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $host_index = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $host_index;
    }

    /**
     * Set the host index
     *
     * @param  int Host index (required)
     */
    public function setHostIndex($host_index)
    {
        $this->hostIndex = $host_index;
    }

    /**
     * Get the host index
     *
     * @return Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation claim
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that claims the task. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function claim($id, $user_id_dto = null)
    {
        $this->claimWithHttpInfo($id, $user_id_dto);
    }

    /**
     * Operation claimWithHttpInfo
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that claims the task. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function claimWithHttpInfo($id, $user_id_dto = null)
    {
        $request = $this->claimRequest($id, $user_id_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation claimAsync
     *
     * 
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that claims the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimAsync($id, $user_id_dto = null)
    {
        return $this->claimAsyncWithHttpInfo($id, $user_id_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation claimAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that claims the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function claimAsyncWithHttpInfo($id, $user_id_dto = null)
    {
        $returnType = '';
        $request = $this->claimRequest($id, $user_id_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'claim'
     *
     * @param  string $id The id of the task to claim. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that claims the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function claimRequest($id, $user_id_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling claim'
            );
        }

        $resourcePath = '/task/{id}/claim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_id_dto)) {
            $_tempBody = $user_id_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation complete
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto complete_task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]|\StrehleDe\CamundaClient\Model\ExceptionDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function complete($id, $complete_task_dto = null)
    {
        list($response) = $this->completeWithHttpInfo($id, $complete_task_dto);
        return $response;
    }

    /**
     * Operation completeWithHttpInfo
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]|\StrehleDe\CamundaClient\Model\ExceptionDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function completeWithHttpInfo($id, $complete_task_dto = null)
    {
        $request = $this->completeRequest($id, $complete_task_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation completeAsync
     *
     * 
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeAsync($id, $complete_task_dto = null)
    {
        return $this->completeAsyncWithHttpInfo($id, $complete_task_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation completeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function completeAsyncWithHttpInfo($id, $complete_task_dto = null)
    {
        $returnType = 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]';
        $request = $this->completeRequest($id, $complete_task_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'complete'
     *
     * @param  string $id The id of the task to complete. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function completeRequest($id, $complete_task_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling complete'
            );
        }

        $resourcePath = '/task/{id}/complete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($complete_task_dto)) {
            $_tempBody = $complete_task_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTask
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function createTask($task_dto = null)
    {
        $this->createTaskWithHttpInfo($task_dto);
    }

    /**
     * Operation createTaskWithHttpInfo
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTaskWithHttpInfo($task_dto = null)
    {
        $request = $this->createTaskRequest($task_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTaskAsync
     *
     * 
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsync($task_dto = null)
    {
        return $this->createTaskAsyncWithHttpInfo($task_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTaskAsyncWithHttpInfo
     *
     * 
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTaskAsyncWithHttpInfo($task_dto = null)
    {
        $returnType = '';
        $request = $this->createTaskRequest($task_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTask'
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createTaskRequest($task_dto = null)
    {

        $resourcePath = '/task/create';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($task_dto)) {
            $_tempBody = $task_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation delegateTask
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function delegateTask($id, $user_id_dto = null)
    {
        $this->delegateTaskWithHttpInfo($id, $user_id_dto);
    }

    /**
     * Operation delegateTaskWithHttpInfo
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function delegateTaskWithHttpInfo($id, $user_id_dto = null)
    {
        $request = $this->delegateTaskRequest($id, $user_id_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation delegateTaskAsync
     *
     * 
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function delegateTaskAsync($id, $user_id_dto = null)
    {
        return $this->delegateTaskAsyncWithHttpInfo($id, $user_id_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation delegateTaskAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function delegateTaskAsyncWithHttpInfo($id, $user_id_dto = null)
    {
        $returnType = '';
        $request = $this->delegateTaskRequest($id, $user_id_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'delegateTask'
     *
     * @param  string $id The id of the task to delegate. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that the task should be delegated to. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function delegateTaskRequest($id, $user_id_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling delegateTask'
            );
        }

        $resourcePath = '/task/{id}/delegate';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_id_dto)) {
            $_tempBody = $user_id_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTask
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteTask($id)
    {
        $this->deleteTaskWithHttpInfo($id);
    }

    /**
     * Operation deleteTaskWithHttpInfo
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTaskWithHttpInfo($id)
    {
        $request = $this->deleteTaskRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTaskAsync
     *
     * 
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsync($id)
    {
        return $this->deleteTaskAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTaskAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTaskAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->deleteTaskRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTask'
     *
     * @param  string $id The id of the task to be removed. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteTaskRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling deleteTask'
            );
        }

        $resourcePath = '/task/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeployedForm
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\StrehleDe\CamundaClient\Model\ExceptionDto|\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getDeployedForm($id)
    {
        list($response) = $this->getDeployedFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getDeployedFormWithHttpInfo
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\StrehleDe\CamundaClient\Model\ExceptionDto|\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeployedFormWithHttpInfo($id)
    {
        $request = $this->getDeployedFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 403:
                    if ('\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeployedFormAsync
     *
     * 
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedFormAsync($id)
    {
        return $this->getDeployedFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeployedFormAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeployedFormAsyncWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->getDeployedFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeployedForm'
     *
     * @param  string $id The id of the task to get the deployed form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeployedFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getDeployedForm'
            );
        }

        $resourcePath = '/task/{id}/deployed-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getForm
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\FormDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getForm($id)
    {
        list($response) = $this->getFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getFormWithHttpInfo
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\FormDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFormWithHttpInfo($id)
    {
        $request = $this->getFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\FormDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\FormDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\FormDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\FormDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFormAsync
     *
     * 
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormAsync($id)
    {
        return $this->getFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFormAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormAsyncWithHttpInfo($id)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\FormDto';
        $request = $this->getFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getForm'
     *
     * @param  string $id The id of the task to retrieve the form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getForm'
            );
        }

        $resourcePath = '/task/{id}/form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFormVariables
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getFormVariables($id, $variable_names = null, $deserialize_values = true)
    {
        list($response) = $this->getFormVariablesWithHttpInfo($id, $variable_names, $deserialize_values);
        return $response;
    }

    /**
     * Operation getFormVariablesWithHttpInfo
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getFormVariablesWithHttpInfo($id, $variable_names = null, $deserialize_values = true)
    {
        $request = $this->getFormVariablesRequest($id, $variable_names, $deserialize_values);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFormVariablesAsync
     *
     * 
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormVariablesAsync($id, $variable_names = null, $deserialize_values = true)
    {
        return $this->getFormVariablesAsyncWithHttpInfo($id, $variable_names, $deserialize_values)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFormVariablesAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFormVariablesAsyncWithHttpInfo($id, $variable_names = null, $deserialize_values = true)
    {
        $returnType = 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]';
        $request = $this->getFormVariablesRequest($id, $variable_names, $deserialize_values);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFormVariables'
     *
     * @param  string $id The id of the task to retrieve the variables for. (required)
     * @param  string $variable_names A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored. (optional)
     * @param  bool $deserialize_values Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#39;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#39;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine. (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getFormVariablesRequest($id, $variable_names = null, $deserialize_values = true)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getFormVariables'
            );
        }

        $resourcePath = '/task/{id}/form-variables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($variable_names !== null) {
            if('form' === 'form' && is_array($variable_names)) {
                foreach($variable_names as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNames'] = $variable_names;
            }
        }
        // query params
        if ($deserialize_values !== null) {
            if('form' === 'form' && is_array($deserialize_values)) {
                foreach($deserialize_values as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['deserializeValues'] = $deserialize_values;
            }
        }


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRenderedForm
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getRenderedForm($id)
    {
        list($response) = $this->getRenderedFormWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getRenderedFormWithHttpInfo
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRenderedFormWithHttpInfo($id)
    {
        $request = $this->getRenderedFormRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\SplFileObject' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\SplFileObject', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\SplFileObject';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRenderedFormAsync
     *
     * 
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedFormAsync($id)
    {
        return $this->getRenderedFormAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRenderedFormAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRenderedFormAsyncWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->getRenderedFormRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRenderedForm'
     *
     * @param  string $id The id of the task to get the rendered form for. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getRenderedFormRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getRenderedForm'
            );
        }

        $resourcePath = '/task/{id}/rendered-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/xhtml+xml', 'application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/xhtml+xml', 'application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTask
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\TaskDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getTask($id)
    {
        list($response) = $this->getTaskWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation getTaskWithHttpInfo
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\TaskDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTaskWithHttpInfo($id)
    {
        $request = $this->getTaskRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\TaskDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\TaskDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\TaskDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\TaskDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTaskAsync
     *
     * 
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsync($id)
    {
        return $this->getTaskAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTaskAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTaskAsyncWithHttpInfo($id)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\TaskDto';
        $request = $this->getTaskRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTask'
     *
     * @param  string $id The id of the task to be retrieved. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTaskRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getTask'
            );
        }

        $resourcePath = '/task/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTasks
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\TaskDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getTasks($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        list($response) = $this->getTasksWithHttpInfo($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results);
        return $response;
    }

    /**
     * Operation getTasksWithHttpInfo
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\TaskDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksWithHttpInfo($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $request = $this->getTasksRequest($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\TaskDto[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\TaskDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\TaskDto[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\TaskDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTasksAsync
     *
     * 
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksAsync($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        return $this->getTasksAsyncWithHttpInfo($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTasksAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksAsyncWithHttpInfo($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\TaskDto[]';
        $request = $this->getTasksRequest($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id, $sort_by, $sort_order, $first_result, $max_results);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTasks'
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     * @param  string $sort_by Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter. (optional)
     * @param  string $sort_order Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter. (optional)
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTasksRequest($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null, $sort_by = null, $sort_order = null, $first_result = null, $max_results = null)
    {

        $resourcePath = '/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($process_instance_id !== null) {
            if('form' === 'form' && is_array($process_instance_id)) {
                foreach($process_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceId'] = $process_instance_id;
            }
        }
        // query params
        if ($process_instance_id_in !== null) {
            if('form' === 'form' && is_array($process_instance_id_in)) {
                foreach($process_instance_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceIdIn'] = $process_instance_id_in;
            }
        }
        // query params
        if ($process_instance_business_key !== null) {
            if('form' === 'form' && is_array($process_instance_business_key)) {
                foreach($process_instance_business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKey'] = $process_instance_business_key;
            }
        }
        // query params
        if ($process_instance_business_key_expression !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_expression)) {
                foreach($process_instance_business_key_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyExpression'] = $process_instance_business_key_expression;
            }
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_in)) {
                foreach($process_instance_business_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyIn'] = $process_instance_business_key_in;
            }
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_like)) {
                foreach($process_instance_business_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyLike'] = $process_instance_business_key_like;
            }
        }
        // query params
        if ($process_instance_business_key_like_expression !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_like_expression)) {
                foreach($process_instance_business_key_like_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyLikeExpression'] = $process_instance_business_key_like_expression;
            }
        }
        // query params
        if ($process_definition_id !== null) {
            if('form' === 'form' && is_array($process_definition_id)) {
                foreach($process_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionId'] = $process_definition_id;
            }
        }
        // query params
        if ($process_definition_key !== null) {
            if('form' === 'form' && is_array($process_definition_key)) {
                foreach($process_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKey'] = $process_definition_key;
            }
        }
        // query params
        if ($process_definition_key_in !== null) {
            if('form' === 'form' && is_array($process_definition_key_in)) {
                foreach($process_definition_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKeyIn'] = $process_definition_key_in;
            }
        }
        // query params
        if ($process_definition_name !== null) {
            if('form' === 'form' && is_array($process_definition_name)) {
                foreach($process_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionName'] = $process_definition_name;
            }
        }
        // query params
        if ($process_definition_name_like !== null) {
            if('form' === 'form' && is_array($process_definition_name_like)) {
                foreach($process_definition_name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionNameLike'] = $process_definition_name_like;
            }
        }
        // query params
        if ($execution_id !== null) {
            if('form' === 'form' && is_array($execution_id)) {
                foreach($execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['executionId'] = $execution_id;
            }
        }
        // query params
        if ($case_instance_id !== null) {
            if('form' === 'form' && is_array($case_instance_id)) {
                foreach($case_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceId'] = $case_instance_id;
            }
        }
        // query params
        if ($case_instance_business_key !== null) {
            if('form' === 'form' && is_array($case_instance_business_key)) {
                foreach($case_instance_business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceBusinessKey'] = $case_instance_business_key;
            }
        }
        // query params
        if ($case_instance_business_key_like !== null) {
            if('form' === 'form' && is_array($case_instance_business_key_like)) {
                foreach($case_instance_business_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceBusinessKeyLike'] = $case_instance_business_key_like;
            }
        }
        // query params
        if ($case_definition_id !== null) {
            if('form' === 'form' && is_array($case_definition_id)) {
                foreach($case_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionId'] = $case_definition_id;
            }
        }
        // query params
        if ($case_definition_key !== null) {
            if('form' === 'form' && is_array($case_definition_key)) {
                foreach($case_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionKey'] = $case_definition_key;
            }
        }
        // query params
        if ($case_definition_name !== null) {
            if('form' === 'form' && is_array($case_definition_name)) {
                foreach($case_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionName'] = $case_definition_name;
            }
        }
        // query params
        if ($case_definition_name_like !== null) {
            if('form' === 'form' && is_array($case_definition_name_like)) {
                foreach($case_definition_name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionNameLike'] = $case_definition_name_like;
            }
        }
        // query params
        if ($case_execution_id !== null) {
            if('form' === 'form' && is_array($case_execution_id)) {
                foreach($case_execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseExecutionId'] = $case_execution_id;
            }
        }
        // query params
        if ($activity_instance_id_in !== null) {
            if('form' === 'form' && is_array($activity_instance_id_in)) {
                foreach($activity_instance_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['activityInstanceIdIn'] = $activity_instance_id_in;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($without_tenant_id !== null) {
            if('form' === 'form' && is_array($without_tenant_id)) {
                foreach($without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTenantId'] = $without_tenant_id;
            }
        }
        // query params
        if ($assignee !== null) {
            if('form' === 'form' && is_array($assignee)) {
                foreach($assignee as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assignee'] = $assignee;
            }
        }
        // query params
        if ($assignee_expression !== null) {
            if('form' === 'form' && is_array($assignee_expression)) {
                foreach($assignee_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeExpression'] = $assignee_expression;
            }
        }
        // query params
        if ($assignee_like !== null) {
            if('form' === 'form' && is_array($assignee_like)) {
                foreach($assignee_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeLike'] = $assignee_like;
            }
        }
        // query params
        if ($assignee_like_expression !== null) {
            if('form' === 'form' && is_array($assignee_like_expression)) {
                foreach($assignee_like_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeLikeExpression'] = $assignee_like_expression;
            }
        }
        // query params
        if ($assignee_in !== null) {
            if('form' === 'form' && is_array($assignee_in)) {
                foreach($assignee_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeIn'] = $assignee_in;
            }
        }
        // query params
        if ($owner !== null) {
            if('form' === 'form' && is_array($owner)) {
                foreach($owner as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['owner'] = $owner;
            }
        }
        // query params
        if ($owner_expression !== null) {
            if('form' === 'form' && is_array($owner_expression)) {
                foreach($owner_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ownerExpression'] = $owner_expression;
            }
        }
        // query params
        if ($candidate_group !== null) {
            if('form' === 'form' && is_array($candidate_group)) {
                foreach($candidate_group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroup'] = $candidate_group;
            }
        }
        // query params
        if ($candidate_group_expression !== null) {
            if('form' === 'form' && is_array($candidate_group_expression)) {
                foreach($candidate_group_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroupExpression'] = $candidate_group_expression;
            }
        }
        // query params
        if ($candidate_user !== null) {
            if('form' === 'form' && is_array($candidate_user)) {
                foreach($candidate_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateUser'] = $candidate_user;
            }
        }
        // query params
        if ($candidate_user_expression !== null) {
            if('form' === 'form' && is_array($candidate_user_expression)) {
                foreach($candidate_user_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateUserExpression'] = $candidate_user_expression;
            }
        }
        // query params
        if ($include_assigned_tasks !== null) {
            if('form' === 'form' && is_array($include_assigned_tasks)) {
                foreach($include_assigned_tasks as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeAssignedTasks'] = $include_assigned_tasks;
            }
        }
        // query params
        if ($involved_user !== null) {
            if('form' === 'form' && is_array($involved_user)) {
                foreach($involved_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['involvedUser'] = $involved_user;
            }
        }
        // query params
        if ($involved_user_expression !== null) {
            if('form' === 'form' && is_array($involved_user_expression)) {
                foreach($involved_user_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['involvedUserExpression'] = $involved_user_expression;
            }
        }
        // query params
        if ($assigned !== null) {
            if('form' === 'form' && is_array($assigned)) {
                foreach($assigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigned'] = $assigned;
            }
        }
        // query params
        if ($unassigned !== null) {
            if('form' === 'form' && is_array($unassigned)) {
                foreach($unassigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['unassigned'] = $unassigned;
            }
        }
        // query params
        if ($task_definition_key !== null) {
            if('form' === 'form' && is_array($task_definition_key)) {
                foreach($task_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKey'] = $task_definition_key;
            }
        }
        // query params
        if ($task_definition_key_in !== null) {
            if('form' === 'form' && is_array($task_definition_key_in)) {
                foreach($task_definition_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKeyIn'] = $task_definition_key_in;
            }
        }
        // query params
        if ($task_definition_key_like !== null) {
            if('form' === 'form' && is_array($task_definition_key_like)) {
                foreach($task_definition_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKeyLike'] = $task_definition_key_like;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($name_not_equal !== null) {
            if('form' === 'form' && is_array($name_not_equal)) {
                foreach($name_not_equal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameNotEqual'] = $name_not_equal;
            }
        }
        // query params
        if ($name_like !== null) {
            if('form' === 'form' && is_array($name_like)) {
                foreach($name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameLike'] = $name_like;
            }
        }
        // query params
        if ($name_not_like !== null) {
            if('form' === 'form' && is_array($name_not_like)) {
                foreach($name_not_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameNotLike'] = $name_not_like;
            }
        }
        // query params
        if ($description !== null) {
            if('form' === 'form' && is_array($description)) {
                foreach($description as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['description'] = $description;
            }
        }
        // query params
        if ($description_like !== null) {
            if('form' === 'form' && is_array($description_like)) {
                foreach($description_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['descriptionLike'] = $description_like;
            }
        }
        // query params
        if ($priority !== null) {
            if('form' === 'form' && is_array($priority)) {
                foreach($priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['priority'] = $priority;
            }
        }
        // query params
        if ($max_priority !== null) {
            if('form' === 'form' && is_array($max_priority)) {
                foreach($max_priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxPriority'] = $max_priority;
            }
        }
        // query params
        if ($min_priority !== null) {
            if('form' === 'form' && is_array($min_priority)) {
                foreach($min_priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['minPriority'] = $min_priority;
            }
        }
        // query params
        if ($due_date !== null) {
            if('form' === 'form' && is_array($due_date)) {
                foreach($due_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueDate'] = $due_date;
            }
        }
        // query params
        if ($due_date_expression !== null) {
            if('form' === 'form' && is_array($due_date_expression)) {
                foreach($due_date_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueDateExpression'] = $due_date_expression;
            }
        }
        // query params
        if ($due_after !== null) {
            if('form' === 'form' && is_array($due_after)) {
                foreach($due_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueAfter'] = $due_after;
            }
        }
        // query params
        if ($due_after_expression !== null) {
            if('form' === 'form' && is_array($due_after_expression)) {
                foreach($due_after_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueAfterExpression'] = $due_after_expression;
            }
        }
        // query params
        if ($due_before !== null) {
            if('form' === 'form' && is_array($due_before)) {
                foreach($due_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueBefore'] = $due_before;
            }
        }
        // query params
        if ($due_before_expression !== null) {
            if('form' === 'form' && is_array($due_before_expression)) {
                foreach($due_before_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueBeforeExpression'] = $due_before_expression;
            }
        }
        // query params
        if ($follow_up_date !== null) {
            if('form' === 'form' && is_array($follow_up_date)) {
                foreach($follow_up_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpDate'] = $follow_up_date;
            }
        }
        // query params
        if ($follow_up_date_expression !== null) {
            if('form' === 'form' && is_array($follow_up_date_expression)) {
                foreach($follow_up_date_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpDateExpression'] = $follow_up_date_expression;
            }
        }
        // query params
        if ($follow_up_after !== null) {
            if('form' === 'form' && is_array($follow_up_after)) {
                foreach($follow_up_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpAfter'] = $follow_up_after;
            }
        }
        // query params
        if ($follow_up_after_expression !== null) {
            if('form' === 'form' && is_array($follow_up_after_expression)) {
                foreach($follow_up_after_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpAfterExpression'] = $follow_up_after_expression;
            }
        }
        // query params
        if ($follow_up_before !== null) {
            if('form' === 'form' && is_array($follow_up_before)) {
                foreach($follow_up_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBefore'] = $follow_up_before;
            }
        }
        // query params
        if ($follow_up_before_expression !== null) {
            if('form' === 'form' && is_array($follow_up_before_expression)) {
                foreach($follow_up_before_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBeforeExpression'] = $follow_up_before_expression;
            }
        }
        // query params
        if ($follow_up_before_or_not_existent !== null) {
            if('form' === 'form' && is_array($follow_up_before_or_not_existent)) {
                foreach($follow_up_before_or_not_existent as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBeforeOrNotExistent'] = $follow_up_before_or_not_existent;
            }
        }
        // query params
        if ($follow_up_before_or_not_existent_expression !== null) {
            if('form' === 'form' && is_array($follow_up_before_or_not_existent_expression)) {
                foreach($follow_up_before_or_not_existent_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBeforeOrNotExistentExpression'] = $follow_up_before_or_not_existent_expression;
            }
        }
        // query params
        if ($created_on !== null) {
            if('form' === 'form' && is_array($created_on)) {
                foreach($created_on as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdOn'] = $created_on;
            }
        }
        // query params
        if ($created_on_expression !== null) {
            if('form' === 'form' && is_array($created_on_expression)) {
                foreach($created_on_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdOnExpression'] = $created_on_expression;
            }
        }
        // query params
        if ($created_after !== null) {
            if('form' === 'form' && is_array($created_after)) {
                foreach($created_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdAfter'] = $created_after;
            }
        }
        // query params
        if ($created_after_expression !== null) {
            if('form' === 'form' && is_array($created_after_expression)) {
                foreach($created_after_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdAfterExpression'] = $created_after_expression;
            }
        }
        // query params
        if ($created_before !== null) {
            if('form' === 'form' && is_array($created_before)) {
                foreach($created_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdBefore'] = $created_before;
            }
        }
        // query params
        if ($created_before_expression !== null) {
            if('form' === 'form' && is_array($created_before_expression)) {
                foreach($created_before_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdBeforeExpression'] = $created_before_expression;
            }
        }
        // query params
        if ($delegation_state !== null) {
            if('form' === 'form' && is_array($delegation_state)) {
                foreach($delegation_state as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['delegationState'] = $delegation_state;
            }
        }
        // query params
        if ($candidate_groups !== null) {
            if('form' === 'form' && is_array($candidate_groups)) {
                foreach($candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroups'] = $candidate_groups;
            }
        }
        // query params
        if ($candidate_groups_expression !== null) {
            if('form' === 'form' && is_array($candidate_groups_expression)) {
                foreach($candidate_groups_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroupsExpression'] = $candidate_groups_expression;
            }
        }
        // query params
        if ($with_candidate_groups !== null) {
            if('form' === 'form' && is_array($with_candidate_groups)) {
                foreach($with_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withCandidateGroups'] = $with_candidate_groups;
            }
        }
        // query params
        if ($without_candidate_groups !== null) {
            if('form' === 'form' && is_array($without_candidate_groups)) {
                foreach($without_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutCandidateGroups'] = $without_candidate_groups;
            }
        }
        // query params
        if ($with_candidate_users !== null) {
            if('form' === 'form' && is_array($with_candidate_users)) {
                foreach($with_candidate_users as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withCandidateUsers'] = $with_candidate_users;
            }
        }
        // query params
        if ($without_candidate_users !== null) {
            if('form' === 'form' && is_array($without_candidate_users)) {
                foreach($without_candidate_users as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutCandidateUsers'] = $without_candidate_users;
            }
        }
        // query params
        if ($active !== null) {
            if('form' === 'form' && is_array($active)) {
                foreach($active as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['active'] = $active;
            }
        }
        // query params
        if ($suspended !== null) {
            if('form' === 'form' && is_array($suspended)) {
                foreach($suspended as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['suspended'] = $suspended;
            }
        }
        // query params
        if ($task_variables !== null) {
            if('form' === 'form' && is_array($task_variables)) {
                foreach($task_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskVariables'] = $task_variables;
            }
        }
        // query params
        if ($process_variables !== null) {
            if('form' === 'form' && is_array($process_variables)) {
                foreach($process_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processVariables'] = $process_variables;
            }
        }
        // query params
        if ($case_instance_variables !== null) {
            if('form' === 'form' && is_array($case_instance_variables)) {
                foreach($case_instance_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceVariables'] = $case_instance_variables;
            }
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_names_ignore_case)) {
                foreach($variable_names_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNamesIgnoreCase'] = $variable_names_ignore_case;
            }
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_values_ignore_case)) {
                foreach($variable_values_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableValuesIgnoreCase'] = $variable_values_ignore_case;
            }
        }
        // query params
        if ($parent_task_id !== null) {
            if('form' === 'form' && is_array($parent_task_id)) {
                foreach($parent_task_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['parentTaskId'] = $parent_task_id;
            }
        }
        // query params
        if ($sort_by !== null) {
            if('form' === 'form' && is_array($sort_by)) {
                foreach($sort_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortBy'] = $sort_by;
            }
        }
        // query params
        if ($sort_order !== null) {
            if('form' === 'form' && is_array($sort_order)) {
                foreach($sort_order as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['sortOrder'] = $sort_order;
            }
        }
        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTasksCount
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\CountResultDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function getTasksCount($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null)
    {
        list($response) = $this->getTasksCountWithHttpInfo($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id);
        return $response;
    }

    /**
     * Operation getTasksCountWithHttpInfo
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\CountResultDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getTasksCountWithHttpInfo($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null)
    {
        $request = $this->getTasksCountRequest($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\CountResultDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\CountResultDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTasksCountAsync
     *
     * 
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksCountAsync($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null)
    {
        return $this->getTasksCountAsyncWithHttpInfo($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTasksCountAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTasksCountAsyncWithHttpInfo($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\CountResultDto';
        $request = $this->getTasksCountRequest($process_instance_id, $process_instance_id_in, $process_instance_business_key, $process_instance_business_key_expression, $process_instance_business_key_in, $process_instance_business_key_like, $process_instance_business_key_like_expression, $process_definition_id, $process_definition_key, $process_definition_key_in, $process_definition_name, $process_definition_name_like, $execution_id, $case_instance_id, $case_instance_business_key, $case_instance_business_key_like, $case_definition_id, $case_definition_key, $case_definition_name, $case_definition_name_like, $case_execution_id, $activity_instance_id_in, $tenant_id_in, $without_tenant_id, $assignee, $assignee_expression, $assignee_like, $assignee_like_expression, $assignee_in, $owner, $owner_expression, $candidate_group, $candidate_group_expression, $candidate_user, $candidate_user_expression, $include_assigned_tasks, $involved_user, $involved_user_expression, $assigned, $unassigned, $task_definition_key, $task_definition_key_in, $task_definition_key_like, $name, $name_not_equal, $name_like, $name_not_like, $description, $description_like, $priority, $max_priority, $min_priority, $due_date, $due_date_expression, $due_after, $due_after_expression, $due_before, $due_before_expression, $follow_up_date, $follow_up_date_expression, $follow_up_after, $follow_up_after_expression, $follow_up_before, $follow_up_before_expression, $follow_up_before_or_not_existent, $follow_up_before_or_not_existent_expression, $created_on, $created_on_expression, $created_after, $created_after_expression, $created_before, $created_before_expression, $delegation_state, $candidate_groups, $candidate_groups_expression, $with_candidate_groups, $without_candidate_groups, $with_candidate_users, $without_candidate_users, $active, $suspended, $task_variables, $process_variables, $case_instance_variables, $variable_names_ignore_case, $variable_values_ignore_case, $parent_task_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTasksCount'
     *
     * @param  string $process_instance_id Restrict to tasks that belong to process instances with the given id. (optional)
     * @param  string $process_instance_id_in Restrict to tasks that belong to process instances with the given ids. (optional)
     * @param  string $process_instance_business_key Restrict to tasks that belong to process instances with the given business key. (optional)
     * @param  string $process_instance_business_key_expression Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  string $process_instance_business_key_in Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list. (optional)
     * @param  string $process_instance_business_key_like Restrict to tasks that have a process instance business key that has the parameter  value as a substring. (optional)
     * @param  string $process_instance_business_key_like_expression Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $process_definition_id Restrict to tasks that belong to a process definition with the given id. (optional)
     * @param  string $process_definition_key Restrict to tasks that belong to a process definition with the given key. (optional)
     * @param  string $process_definition_key_in Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list. (optional)
     * @param  string $process_definition_name Restrict to tasks that belong to a process definition with the given name. (optional)
     * @param  string $process_definition_name_like Restrict to tasks that have a process definition name that has the parameter value as  a substring. (optional)
     * @param  string $execution_id Restrict to tasks that belong to an execution with the given id. (optional)
     * @param  string $case_instance_id Restrict to tasks that belong to case instances with the given id. (optional)
     * @param  string $case_instance_business_key Restrict to tasks that belong to case instances with the given business key. (optional)
     * @param  string $case_instance_business_key_like Restrict to tasks that have a case instance business key that has the parameter value  as a substring. (optional)
     * @param  string $case_definition_id Restrict to tasks that belong to a case definition with the given id. (optional)
     * @param  string $case_definition_key Restrict to tasks that belong to a case definition with the given key. (optional)
     * @param  string $case_definition_name Restrict to tasks that belong to a case definition with the given name. (optional)
     * @param  string $case_definition_name_like Restrict to tasks that have a case definition name that has the parameter value as a  substring. (optional)
     * @param  string $case_execution_id Restrict to tasks that belong to a case execution with the given id. (optional)
     * @param  string $activity_instance_id_in Only include tasks which belong to one of the passed and comma-separated activity  instance ids. (optional)
     * @param  string $tenant_id_in Only include tasks which belong to one of the passed and comma-separated  tenant ids. (optional)
     * @param  bool $without_tenant_id Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $assignee Restrict to tasks that the given user is assigned to. (optional)
     * @param  string $assignee_expression Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_like Restrict to tasks that have an assignee that has the parameter  value as a substring. (optional)
     * @param  string $assignee_like_expression Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $assignee_in Only include tasks which are assigned to one of the passed and  comma-separated user ids. (optional)
     * @param  string $owner Restrict to tasks that the given user owns. (optional)
     * @param  string $owner_expression Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_group Only include tasks that are offered to the given group. (optional)
     * @param  string $candidate_group_expression Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  string $candidate_user Only include tasks that are offered to the given user or to one of his groups. (optional)
     * @param  string $candidate_user_expression Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions. (optional)
     * @param  bool $include_assigned_tasks Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s). (optional, default to false)
     * @param  string $involved_user Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee). (optional)
     * @param  string $involved_user_expression Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. (optional)
     * @param  bool $assigned If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned. (optional, default to false)
     * @param  bool $unassigned If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned. (optional, default to false)
     * @param  string $task_definition_key Restrict to tasks that have the given key. (optional)
     * @param  string $task_definition_key_in Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list. (optional)
     * @param  string $task_definition_key_like Restrict to tasks that have a key that has the parameter value as a substring. (optional)
     * @param  string $name Restrict to tasks that have the given name. (optional)
     * @param  string $name_not_equal Restrict to tasks that do not have the given name. (optional)
     * @param  string $name_like Restrict to tasks that have a name with the given parameter value as substring. (optional)
     * @param  string $name_not_like Restrict to tasks that do not have a name with the given parameter value as substring. (optional)
     * @param  string $description Restrict to tasks that have the given description. (optional)
     * @param  string $description_like Restrict to tasks that have a description that has the parameter value as a substring. (optional)
     * @param  int $priority Restrict to tasks that have the given priority. (optional)
     * @param  int $max_priority Restrict to tasks that have a lower or equal priority. (optional)
     * @param  int $min_priority Restrict to tasks that have a higher or equal priority. (optional)
     * @param  string $due_date Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;. (optional)
     * @param  string $due_date_expression Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_after Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;. (optional)
     * @param  string $due_after_expression Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $due_before Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;. (optional)
     * @param  string $due_before_expression Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_date Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $follow_up_date_expression Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_after Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;. (optional)
     * @param  string $follow_up_after_expression Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;. (optional)
     * @param  string $follow_up_before_expression Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $follow_up_before_or_not_existent Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date. (optional)
     * @param  string $follow_up_before_or_not_existent_expression Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_on Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;. (optional)
     * @param  string $created_on_expression Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_after Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;. (optional)
     * @param  string $created_after_expression Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $created_before Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;. (optional)
     * @param  string $created_before_expression Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object. (optional)
     * @param  string $delegation_state Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;. (optional)
     * @param  string $candidate_groups Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;. (optional)
     * @param  string $candidate_groups_expression Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings. (optional)
     * @param  bool $with_candidate_groups Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_groups Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $with_candidate_users Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $without_candidate_users Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $active Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  bool $suspended Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior. (optional, default to false)
     * @param  string $task_variables Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $process_variables Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  string $case_instance_variables Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters. (optional)
     * @param  bool $variable_names_ignore_case Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal. (optional, default to false)
     * @param  bool $variable_values_ignore_case Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal. (optional, default to false)
     * @param  string $parent_task_id Restrict query to all tasks that are sub tasks of the given task. Takes a task id. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getTasksCountRequest($process_instance_id = null, $process_instance_id_in = null, $process_instance_business_key = null, $process_instance_business_key_expression = null, $process_instance_business_key_in = null, $process_instance_business_key_like = null, $process_instance_business_key_like_expression = null, $process_definition_id = null, $process_definition_key = null, $process_definition_key_in = null, $process_definition_name = null, $process_definition_name_like = null, $execution_id = null, $case_instance_id = null, $case_instance_business_key = null, $case_instance_business_key_like = null, $case_definition_id = null, $case_definition_key = null, $case_definition_name = null, $case_definition_name_like = null, $case_execution_id = null, $activity_instance_id_in = null, $tenant_id_in = null, $without_tenant_id = false, $assignee = null, $assignee_expression = null, $assignee_like = null, $assignee_like_expression = null, $assignee_in = null, $owner = null, $owner_expression = null, $candidate_group = null, $candidate_group_expression = null, $candidate_user = null, $candidate_user_expression = null, $include_assigned_tasks = false, $involved_user = null, $involved_user_expression = null, $assigned = false, $unassigned = false, $task_definition_key = null, $task_definition_key_in = null, $task_definition_key_like = null, $name = null, $name_not_equal = null, $name_like = null, $name_not_like = null, $description = null, $description_like = null, $priority = null, $max_priority = null, $min_priority = null, $due_date = null, $due_date_expression = null, $due_after = null, $due_after_expression = null, $due_before = null, $due_before_expression = null, $follow_up_date = null, $follow_up_date_expression = null, $follow_up_after = null, $follow_up_after_expression = null, $follow_up_before = null, $follow_up_before_expression = null, $follow_up_before_or_not_existent = null, $follow_up_before_or_not_existent_expression = null, $created_on = null, $created_on_expression = null, $created_after = null, $created_after_expression = null, $created_before = null, $created_before_expression = null, $delegation_state = null, $candidate_groups = null, $candidate_groups_expression = null, $with_candidate_groups = false, $without_candidate_groups = false, $with_candidate_users = false, $without_candidate_users = false, $active = false, $suspended = false, $task_variables = null, $process_variables = null, $case_instance_variables = null, $variable_names_ignore_case = false, $variable_values_ignore_case = false, $parent_task_id = null)
    {

        $resourcePath = '/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($process_instance_id !== null) {
            if('form' === 'form' && is_array($process_instance_id)) {
                foreach($process_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceId'] = $process_instance_id;
            }
        }
        // query params
        if ($process_instance_id_in !== null) {
            if('form' === 'form' && is_array($process_instance_id_in)) {
                foreach($process_instance_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceIdIn'] = $process_instance_id_in;
            }
        }
        // query params
        if ($process_instance_business_key !== null) {
            if('form' === 'form' && is_array($process_instance_business_key)) {
                foreach($process_instance_business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKey'] = $process_instance_business_key;
            }
        }
        // query params
        if ($process_instance_business_key_expression !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_expression)) {
                foreach($process_instance_business_key_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyExpression'] = $process_instance_business_key_expression;
            }
        }
        // query params
        if ($process_instance_business_key_in !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_in)) {
                foreach($process_instance_business_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyIn'] = $process_instance_business_key_in;
            }
        }
        // query params
        if ($process_instance_business_key_like !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_like)) {
                foreach($process_instance_business_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyLike'] = $process_instance_business_key_like;
            }
        }
        // query params
        if ($process_instance_business_key_like_expression !== null) {
            if('form' === 'form' && is_array($process_instance_business_key_like_expression)) {
                foreach($process_instance_business_key_like_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processInstanceBusinessKeyLikeExpression'] = $process_instance_business_key_like_expression;
            }
        }
        // query params
        if ($process_definition_id !== null) {
            if('form' === 'form' && is_array($process_definition_id)) {
                foreach($process_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionId'] = $process_definition_id;
            }
        }
        // query params
        if ($process_definition_key !== null) {
            if('form' === 'form' && is_array($process_definition_key)) {
                foreach($process_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKey'] = $process_definition_key;
            }
        }
        // query params
        if ($process_definition_key_in !== null) {
            if('form' === 'form' && is_array($process_definition_key_in)) {
                foreach($process_definition_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionKeyIn'] = $process_definition_key_in;
            }
        }
        // query params
        if ($process_definition_name !== null) {
            if('form' === 'form' && is_array($process_definition_name)) {
                foreach($process_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionName'] = $process_definition_name;
            }
        }
        // query params
        if ($process_definition_name_like !== null) {
            if('form' === 'form' && is_array($process_definition_name_like)) {
                foreach($process_definition_name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processDefinitionNameLike'] = $process_definition_name_like;
            }
        }
        // query params
        if ($execution_id !== null) {
            if('form' === 'form' && is_array($execution_id)) {
                foreach($execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['executionId'] = $execution_id;
            }
        }
        // query params
        if ($case_instance_id !== null) {
            if('form' === 'form' && is_array($case_instance_id)) {
                foreach($case_instance_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceId'] = $case_instance_id;
            }
        }
        // query params
        if ($case_instance_business_key !== null) {
            if('form' === 'form' && is_array($case_instance_business_key)) {
                foreach($case_instance_business_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceBusinessKey'] = $case_instance_business_key;
            }
        }
        // query params
        if ($case_instance_business_key_like !== null) {
            if('form' === 'form' && is_array($case_instance_business_key_like)) {
                foreach($case_instance_business_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceBusinessKeyLike'] = $case_instance_business_key_like;
            }
        }
        // query params
        if ($case_definition_id !== null) {
            if('form' === 'form' && is_array($case_definition_id)) {
                foreach($case_definition_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionId'] = $case_definition_id;
            }
        }
        // query params
        if ($case_definition_key !== null) {
            if('form' === 'form' && is_array($case_definition_key)) {
                foreach($case_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionKey'] = $case_definition_key;
            }
        }
        // query params
        if ($case_definition_name !== null) {
            if('form' === 'form' && is_array($case_definition_name)) {
                foreach($case_definition_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionName'] = $case_definition_name;
            }
        }
        // query params
        if ($case_definition_name_like !== null) {
            if('form' === 'form' && is_array($case_definition_name_like)) {
                foreach($case_definition_name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseDefinitionNameLike'] = $case_definition_name_like;
            }
        }
        // query params
        if ($case_execution_id !== null) {
            if('form' === 'form' && is_array($case_execution_id)) {
                foreach($case_execution_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseExecutionId'] = $case_execution_id;
            }
        }
        // query params
        if ($activity_instance_id_in !== null) {
            if('form' === 'form' && is_array($activity_instance_id_in)) {
                foreach($activity_instance_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['activityInstanceIdIn'] = $activity_instance_id_in;
            }
        }
        // query params
        if ($tenant_id_in !== null) {
            if('form' === 'form' && is_array($tenant_id_in)) {
                foreach($tenant_id_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['tenantIdIn'] = $tenant_id_in;
            }
        }
        // query params
        if ($without_tenant_id !== null) {
            if('form' === 'form' && is_array($without_tenant_id)) {
                foreach($without_tenant_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutTenantId'] = $without_tenant_id;
            }
        }
        // query params
        if ($assignee !== null) {
            if('form' === 'form' && is_array($assignee)) {
                foreach($assignee as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assignee'] = $assignee;
            }
        }
        // query params
        if ($assignee_expression !== null) {
            if('form' === 'form' && is_array($assignee_expression)) {
                foreach($assignee_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeExpression'] = $assignee_expression;
            }
        }
        // query params
        if ($assignee_like !== null) {
            if('form' === 'form' && is_array($assignee_like)) {
                foreach($assignee_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeLike'] = $assignee_like;
            }
        }
        // query params
        if ($assignee_like_expression !== null) {
            if('form' === 'form' && is_array($assignee_like_expression)) {
                foreach($assignee_like_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeLikeExpression'] = $assignee_like_expression;
            }
        }
        // query params
        if ($assignee_in !== null) {
            if('form' === 'form' && is_array($assignee_in)) {
                foreach($assignee_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigneeIn'] = $assignee_in;
            }
        }
        // query params
        if ($owner !== null) {
            if('form' === 'form' && is_array($owner)) {
                foreach($owner as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['owner'] = $owner;
            }
        }
        // query params
        if ($owner_expression !== null) {
            if('form' === 'form' && is_array($owner_expression)) {
                foreach($owner_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['ownerExpression'] = $owner_expression;
            }
        }
        // query params
        if ($candidate_group !== null) {
            if('form' === 'form' && is_array($candidate_group)) {
                foreach($candidate_group as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroup'] = $candidate_group;
            }
        }
        // query params
        if ($candidate_group_expression !== null) {
            if('form' === 'form' && is_array($candidate_group_expression)) {
                foreach($candidate_group_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroupExpression'] = $candidate_group_expression;
            }
        }
        // query params
        if ($candidate_user !== null) {
            if('form' === 'form' && is_array($candidate_user)) {
                foreach($candidate_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateUser'] = $candidate_user;
            }
        }
        // query params
        if ($candidate_user_expression !== null) {
            if('form' === 'form' && is_array($candidate_user_expression)) {
                foreach($candidate_user_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateUserExpression'] = $candidate_user_expression;
            }
        }
        // query params
        if ($include_assigned_tasks !== null) {
            if('form' === 'form' && is_array($include_assigned_tasks)) {
                foreach($include_assigned_tasks as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['includeAssignedTasks'] = $include_assigned_tasks;
            }
        }
        // query params
        if ($involved_user !== null) {
            if('form' === 'form' && is_array($involved_user)) {
                foreach($involved_user as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['involvedUser'] = $involved_user;
            }
        }
        // query params
        if ($involved_user_expression !== null) {
            if('form' === 'form' && is_array($involved_user_expression)) {
                foreach($involved_user_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['involvedUserExpression'] = $involved_user_expression;
            }
        }
        // query params
        if ($assigned !== null) {
            if('form' === 'form' && is_array($assigned)) {
                foreach($assigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['assigned'] = $assigned;
            }
        }
        // query params
        if ($unassigned !== null) {
            if('form' === 'form' && is_array($unassigned)) {
                foreach($unassigned as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['unassigned'] = $unassigned;
            }
        }
        // query params
        if ($task_definition_key !== null) {
            if('form' === 'form' && is_array($task_definition_key)) {
                foreach($task_definition_key as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKey'] = $task_definition_key;
            }
        }
        // query params
        if ($task_definition_key_in !== null) {
            if('form' === 'form' && is_array($task_definition_key_in)) {
                foreach($task_definition_key_in as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKeyIn'] = $task_definition_key_in;
            }
        }
        // query params
        if ($task_definition_key_like !== null) {
            if('form' === 'form' && is_array($task_definition_key_like)) {
                foreach($task_definition_key_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskDefinitionKeyLike'] = $task_definition_key_like;
            }
        }
        // query params
        if ($name !== null) {
            if('form' === 'form' && is_array($name)) {
                foreach($name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['name'] = $name;
            }
        }
        // query params
        if ($name_not_equal !== null) {
            if('form' === 'form' && is_array($name_not_equal)) {
                foreach($name_not_equal as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameNotEqual'] = $name_not_equal;
            }
        }
        // query params
        if ($name_like !== null) {
            if('form' === 'form' && is_array($name_like)) {
                foreach($name_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameLike'] = $name_like;
            }
        }
        // query params
        if ($name_not_like !== null) {
            if('form' === 'form' && is_array($name_not_like)) {
                foreach($name_not_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['nameNotLike'] = $name_not_like;
            }
        }
        // query params
        if ($description !== null) {
            if('form' === 'form' && is_array($description)) {
                foreach($description as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['description'] = $description;
            }
        }
        // query params
        if ($description_like !== null) {
            if('form' === 'form' && is_array($description_like)) {
                foreach($description_like as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['descriptionLike'] = $description_like;
            }
        }
        // query params
        if ($priority !== null) {
            if('form' === 'form' && is_array($priority)) {
                foreach($priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['priority'] = $priority;
            }
        }
        // query params
        if ($max_priority !== null) {
            if('form' === 'form' && is_array($max_priority)) {
                foreach($max_priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxPriority'] = $max_priority;
            }
        }
        // query params
        if ($min_priority !== null) {
            if('form' === 'form' && is_array($min_priority)) {
                foreach($min_priority as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['minPriority'] = $min_priority;
            }
        }
        // query params
        if ($due_date !== null) {
            if('form' === 'form' && is_array($due_date)) {
                foreach($due_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueDate'] = $due_date;
            }
        }
        // query params
        if ($due_date_expression !== null) {
            if('form' === 'form' && is_array($due_date_expression)) {
                foreach($due_date_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueDateExpression'] = $due_date_expression;
            }
        }
        // query params
        if ($due_after !== null) {
            if('form' === 'form' && is_array($due_after)) {
                foreach($due_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueAfter'] = $due_after;
            }
        }
        // query params
        if ($due_after_expression !== null) {
            if('form' === 'form' && is_array($due_after_expression)) {
                foreach($due_after_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueAfterExpression'] = $due_after_expression;
            }
        }
        // query params
        if ($due_before !== null) {
            if('form' === 'form' && is_array($due_before)) {
                foreach($due_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueBefore'] = $due_before;
            }
        }
        // query params
        if ($due_before_expression !== null) {
            if('form' === 'form' && is_array($due_before_expression)) {
                foreach($due_before_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['dueBeforeExpression'] = $due_before_expression;
            }
        }
        // query params
        if ($follow_up_date !== null) {
            if('form' === 'form' && is_array($follow_up_date)) {
                foreach($follow_up_date as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpDate'] = $follow_up_date;
            }
        }
        // query params
        if ($follow_up_date_expression !== null) {
            if('form' === 'form' && is_array($follow_up_date_expression)) {
                foreach($follow_up_date_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpDateExpression'] = $follow_up_date_expression;
            }
        }
        // query params
        if ($follow_up_after !== null) {
            if('form' === 'form' && is_array($follow_up_after)) {
                foreach($follow_up_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpAfter'] = $follow_up_after;
            }
        }
        // query params
        if ($follow_up_after_expression !== null) {
            if('form' === 'form' && is_array($follow_up_after_expression)) {
                foreach($follow_up_after_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpAfterExpression'] = $follow_up_after_expression;
            }
        }
        // query params
        if ($follow_up_before !== null) {
            if('form' === 'form' && is_array($follow_up_before)) {
                foreach($follow_up_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBefore'] = $follow_up_before;
            }
        }
        // query params
        if ($follow_up_before_expression !== null) {
            if('form' === 'form' && is_array($follow_up_before_expression)) {
                foreach($follow_up_before_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBeforeExpression'] = $follow_up_before_expression;
            }
        }
        // query params
        if ($follow_up_before_or_not_existent !== null) {
            if('form' === 'form' && is_array($follow_up_before_or_not_existent)) {
                foreach($follow_up_before_or_not_existent as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBeforeOrNotExistent'] = $follow_up_before_or_not_existent;
            }
        }
        // query params
        if ($follow_up_before_or_not_existent_expression !== null) {
            if('form' === 'form' && is_array($follow_up_before_or_not_existent_expression)) {
                foreach($follow_up_before_or_not_existent_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['followUpBeforeOrNotExistentExpression'] = $follow_up_before_or_not_existent_expression;
            }
        }
        // query params
        if ($created_on !== null) {
            if('form' === 'form' && is_array($created_on)) {
                foreach($created_on as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdOn'] = $created_on;
            }
        }
        // query params
        if ($created_on_expression !== null) {
            if('form' === 'form' && is_array($created_on_expression)) {
                foreach($created_on_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdOnExpression'] = $created_on_expression;
            }
        }
        // query params
        if ($created_after !== null) {
            if('form' === 'form' && is_array($created_after)) {
                foreach($created_after as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdAfter'] = $created_after;
            }
        }
        // query params
        if ($created_after_expression !== null) {
            if('form' === 'form' && is_array($created_after_expression)) {
                foreach($created_after_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdAfterExpression'] = $created_after_expression;
            }
        }
        // query params
        if ($created_before !== null) {
            if('form' === 'form' && is_array($created_before)) {
                foreach($created_before as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdBefore'] = $created_before;
            }
        }
        // query params
        if ($created_before_expression !== null) {
            if('form' === 'form' && is_array($created_before_expression)) {
                foreach($created_before_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['createdBeforeExpression'] = $created_before_expression;
            }
        }
        // query params
        if ($delegation_state !== null) {
            if('form' === 'form' && is_array($delegation_state)) {
                foreach($delegation_state as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['delegationState'] = $delegation_state;
            }
        }
        // query params
        if ($candidate_groups !== null) {
            if('form' === 'form' && is_array($candidate_groups)) {
                foreach($candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroups'] = $candidate_groups;
            }
        }
        // query params
        if ($candidate_groups_expression !== null) {
            if('form' === 'form' && is_array($candidate_groups_expression)) {
                foreach($candidate_groups_expression as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['candidateGroupsExpression'] = $candidate_groups_expression;
            }
        }
        // query params
        if ($with_candidate_groups !== null) {
            if('form' === 'form' && is_array($with_candidate_groups)) {
                foreach($with_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withCandidateGroups'] = $with_candidate_groups;
            }
        }
        // query params
        if ($without_candidate_groups !== null) {
            if('form' === 'form' && is_array($without_candidate_groups)) {
                foreach($without_candidate_groups as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutCandidateGroups'] = $without_candidate_groups;
            }
        }
        // query params
        if ($with_candidate_users !== null) {
            if('form' === 'form' && is_array($with_candidate_users)) {
                foreach($with_candidate_users as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withCandidateUsers'] = $with_candidate_users;
            }
        }
        // query params
        if ($without_candidate_users !== null) {
            if('form' === 'form' && is_array($without_candidate_users)) {
                foreach($without_candidate_users as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['withoutCandidateUsers'] = $without_candidate_users;
            }
        }
        // query params
        if ($active !== null) {
            if('form' === 'form' && is_array($active)) {
                foreach($active as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['active'] = $active;
            }
        }
        // query params
        if ($suspended !== null) {
            if('form' === 'form' && is_array($suspended)) {
                foreach($suspended as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['suspended'] = $suspended;
            }
        }
        // query params
        if ($task_variables !== null) {
            if('form' === 'form' && is_array($task_variables)) {
                foreach($task_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['taskVariables'] = $task_variables;
            }
        }
        // query params
        if ($process_variables !== null) {
            if('form' === 'form' && is_array($process_variables)) {
                foreach($process_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['processVariables'] = $process_variables;
            }
        }
        // query params
        if ($case_instance_variables !== null) {
            if('form' === 'form' && is_array($case_instance_variables)) {
                foreach($case_instance_variables as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['caseInstanceVariables'] = $case_instance_variables;
            }
        }
        // query params
        if ($variable_names_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_names_ignore_case)) {
                foreach($variable_names_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableNamesIgnoreCase'] = $variable_names_ignore_case;
            }
        }
        // query params
        if ($variable_values_ignore_case !== null) {
            if('form' === 'form' && is_array($variable_values_ignore_case)) {
                foreach($variable_values_ignore_case as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['variableValuesIgnoreCase'] = $variable_values_ignore_case;
            }
        }
        // query params
        if ($parent_task_id !== null) {
            if('form' === 'form' && is_array($parent_task_id)) {
                foreach($parent_task_id as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['parentTaskId'] = $parent_task_id;
            }
        }



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation handleBpmnError
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskBpmnErrorDto $task_bpmn_error_dto task_bpmn_error_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function handleBpmnError($id, $task_bpmn_error_dto = null)
    {
        $this->handleBpmnErrorWithHttpInfo($id, $task_bpmn_error_dto);
    }

    /**
     * Operation handleBpmnErrorWithHttpInfo
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskBpmnErrorDto $task_bpmn_error_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function handleBpmnErrorWithHttpInfo($id, $task_bpmn_error_dto = null)
    {
        $request = $this->handleBpmnErrorRequest($id, $task_bpmn_error_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation handleBpmnErrorAsync
     *
     * 
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskBpmnErrorDto $task_bpmn_error_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleBpmnErrorAsync($id, $task_bpmn_error_dto = null)
    {
        return $this->handleBpmnErrorAsyncWithHttpInfo($id, $task_bpmn_error_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation handleBpmnErrorAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskBpmnErrorDto $task_bpmn_error_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleBpmnErrorAsyncWithHttpInfo($id, $task_bpmn_error_dto = null)
    {
        $returnType = '';
        $request = $this->handleBpmnErrorRequest($id, $task_bpmn_error_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'handleBpmnError'
     *
     * @param  string $id The id of the task a BPMN error is reported for. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskBpmnErrorDto $task_bpmn_error_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function handleBpmnErrorRequest($id, $task_bpmn_error_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling handleBpmnError'
            );
        }

        $resourcePath = '/task/{id}/bpmnError';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($task_bpmn_error_dto)) {
            $_tempBody = $task_bpmn_error_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation handleEscalation
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskEscalationDto $task_escalation_dto task_escalation_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function handleEscalation($id, $task_escalation_dto = null)
    {
        $this->handleEscalationWithHttpInfo($id, $task_escalation_dto);
    }

    /**
     * Operation handleEscalationWithHttpInfo
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskEscalationDto $task_escalation_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function handleEscalationWithHttpInfo($id, $task_escalation_dto = null)
    {
        $request = $this->handleEscalationRequest($id, $task_escalation_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 403:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\AuthorizationExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation handleEscalationAsync
     *
     * 
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskEscalationDto $task_escalation_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleEscalationAsync($id, $task_escalation_dto = null)
    {
        return $this->handleEscalationAsyncWithHttpInfo($id, $task_escalation_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation handleEscalationAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskEscalationDto $task_escalation_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function handleEscalationAsyncWithHttpInfo($id, $task_escalation_dto = null)
    {
        $returnType = '';
        $request = $this->handleEscalationRequest($id, $task_escalation_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'handleEscalation'
     *
     * @param  string $id The id of the task in which context a BPMN escalation is reported. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskEscalationDto $task_escalation_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function handleEscalationRequest($id, $task_escalation_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling handleEscalation'
            );
        }

        $resourcePath = '/task/{id}/bpmnEscalation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($task_escalation_dto)) {
            $_tempBody = $task_escalation_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTasks
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto task_query_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\TaskDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function queryTasks($first_result = null, $max_results = null, $task_query_dto = null)
    {
        list($response) = $this->queryTasksWithHttpInfo($first_result, $max_results, $task_query_dto);
        return $response;
    }

    /**
     * Operation queryTasksWithHttpInfo
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\TaskDto[]|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTasksWithHttpInfo($first_result = null, $max_results = null, $task_query_dto = null)
    {
        $request = $this->queryTasksRequest($first_result, $max_results, $task_query_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\TaskDto[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\TaskDto[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\TaskDto[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\TaskDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTasksAsync
     *
     * 
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksAsync($first_result = null, $max_results = null, $task_query_dto = null)
    {
        return $this->queryTasksAsyncWithHttpInfo($first_result, $max_results, $task_query_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTasksAsyncWithHttpInfo
     *
     * 
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksAsyncWithHttpInfo($first_result = null, $max_results = null, $task_query_dto = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\TaskDto[]';
        $request = $this->queryTasksRequest($first_result, $max_results, $task_query_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTasks'
     *
     * @param  int $first_result Pagination of results. Specifies the index of the first result to return. (optional)
     * @param  int $max_results Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left. (optional)
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTasksRequest($first_result = null, $max_results = null, $task_query_dto = null)
    {

        $resourcePath = '/task';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($first_result !== null) {
            if('form' === 'form' && is_array($first_result)) {
                foreach($first_result as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['firstResult'] = $first_result;
            }
        }
        // query params
        if ($max_results !== null) {
            if('form' === 'form' && is_array($max_results)) {
                foreach($max_results as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['maxResults'] = $max_results;
            }
        }



        // body params
        $_tempBody = null;
        if (isset($task_query_dto)) {
            $_tempBody = $task_query_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation queryTasksCount
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto task_query_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \StrehleDe\CamundaClient\Model\CountResultDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function queryTasksCount($task_query_dto = null)
    {
        list($response) = $this->queryTasksCountWithHttpInfo($task_query_dto);
        return $response;
    }

    /**
     * Operation queryTasksCountWithHttpInfo
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \StrehleDe\CamundaClient\Model\CountResultDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function queryTasksCountWithHttpInfo($task_query_dto = null)
    {
        $request = $this->queryTasksCountRequest($task_query_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\StrehleDe\CamundaClient\Model\CountResultDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\CountResultDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\StrehleDe\CamundaClient\Model\CountResultDto';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\CountResultDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation queryTasksCountAsync
     *
     * 
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksCountAsync($task_query_dto = null)
    {
        return $this->queryTasksCountAsyncWithHttpInfo($task_query_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation queryTasksCountAsyncWithHttpInfo
     *
     * 
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function queryTasksCountAsyncWithHttpInfo($task_query_dto = null)
    {
        $returnType = '\StrehleDe\CamundaClient\Model\CountResultDto';
        $request = $this->queryTasksCountRequest($task_query_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'queryTasksCount'
     *
     * @param  \StrehleDe\CamundaClient\Model\TaskQueryDto $task_query_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function queryTasksCountRequest($task_query_dto = null)
    {

        $resourcePath = '/task/count';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // body params
        $_tempBody = null;
        if (isset($task_query_dto)) {
            $_tempBody = $task_query_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resolve
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto complete_task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resolve($id, $complete_task_dto = null)
    {
        $this->resolveWithHttpInfo($id, $complete_task_dto);
    }

    /**
     * Operation resolveWithHttpInfo
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resolveWithHttpInfo($id, $complete_task_dto = null)
    {
        $request = $this->resolveRequest($id, $complete_task_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resolveAsync
     *
     * 
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resolveAsync($id, $complete_task_dto = null)
    {
        return $this->resolveAsyncWithHttpInfo($id, $complete_task_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resolveAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resolveAsyncWithHttpInfo($id, $complete_task_dto = null)
    {
        $returnType = '';
        $request = $this->resolveRequest($id, $complete_task_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resolve'
     *
     * @param  string $id The id of the task to resolve. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resolveRequest($id, $complete_task_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling resolve'
            );
        }

        $resourcePath = '/task/{id}/resolve';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($complete_task_dto)) {
            $_tempBody = $complete_task_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation setAssignee
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function setAssignee($id, $user_id_dto = null)
    {
        $this->setAssigneeWithHttpInfo($id, $user_id_dto);
    }

    /**
     * Operation setAssigneeWithHttpInfo
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function setAssigneeWithHttpInfo($id, $user_id_dto = null)
    {
        $request = $this->setAssigneeRequest($id, $user_id_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation setAssigneeAsync
     *
     * 
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setAssigneeAsync($id, $user_id_dto = null)
    {
        return $this->setAssigneeAsyncWithHttpInfo($id, $user_id_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation setAssigneeAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function setAssigneeAsyncWithHttpInfo($id, $user_id_dto = null)
    {
        $returnType = '';
        $request = $this->setAssigneeRequest($id, $user_id_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'setAssignee'
     *
     * @param  string $id The id of the task to set the assignee for. (required)
     * @param  \StrehleDe\CamundaClient\Model\UserIdDto $user_id_dto Provide the id of the user that will be the assignee of the task. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function setAssigneeRequest($id, $user_id_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling setAssignee'
            );
        }

        $resourcePath = '/task/{id}/assignee';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($user_id_dto)) {
            $_tempBody = $user_id_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation submit
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto complete_task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]|\StrehleDe\CamundaClient\Model\ExceptionDto|\StrehleDe\CamundaClient\Model\ExceptionDto
     */
    public function submit($id, $complete_task_dto = null)
    {
        list($response) = $this->submitWithHttpInfo($id, $complete_task_dto);
        return $response;
    }

    /**
     * Operation submitWithHttpInfo
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]|\StrehleDe\CamundaClient\Model\ExceptionDto|\StrehleDe\CamundaClient\Model\ExceptionDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function submitWithHttpInfo($id, $complete_task_dto = null)
    {
        $request = $this->submitRequest($id, $complete_task_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\StrehleDe\CamundaClient\Model\ExceptionDto' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\StrehleDe\CamundaClient\Model\ExceptionDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation submitAsync
     *
     * 
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitAsync($id, $complete_task_dto = null)
    {
        return $this->submitAsyncWithHttpInfo($id, $complete_task_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation submitAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function submitAsyncWithHttpInfo($id, $complete_task_dto = null)
    {
        $returnType = 'map[string,\StrehleDe\CamundaClient\Model\VariableValueDto]';
        $request = $this->submitRequest($id, $complete_task_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'submit'
     *
     * @param  string $id The id of the task to submit the form for. (required)
     * @param  \StrehleDe\CamundaClient\Model\CompleteTaskDto $complete_task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function submitRequest($id, $complete_task_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling submit'
            );
        }

        $resourcePath = '/task/{id}/submit-form';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($complete_task_dto)) {
            $_tempBody = $complete_task_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unclaim
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function unclaim($id)
    {
        $this->unclaimWithHttpInfo($id);
    }

    /**
     * Operation unclaimWithHttpInfo
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function unclaimWithHttpInfo($id)
    {
        $request = $this->unclaimRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unclaimAsync
     *
     * 
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unclaimAsync($id)
    {
        return $this->unclaimAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unclaimAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unclaimAsyncWithHttpInfo($id)
    {
        $returnType = '';
        $request = $this->unclaimRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unclaim'
     *
     * @param  string $id The id of the task to unclaim. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function unclaimRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling unclaim'
            );
        }

        $resourcePath = '/task/{id}/unclaim';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTask
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateTask($id, $task_dto = null)
    {
        $this->updateTaskWithHttpInfo($id, $task_dto);
    }

    /**
     * Operation updateTaskWithHttpInfo
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \StrehleDe\CamundaClient\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTaskWithHttpInfo($id, $task_dto = null)
    {
        $request = $this->updateTaskRequest($id, $task_dto);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\StrehleDe\CamundaClient\Model\ExceptionDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTaskAsync
     *
     * 
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsync($id, $task_dto = null)
    {
        return $this->updateTaskAsyncWithHttpInfo($id, $task_dto)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTaskAsyncWithHttpInfo
     *
     * 
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTaskAsyncWithHttpInfo($id, $task_dto = null)
    {
        $returnType = '';
        $request = $this->updateTaskRequest($id, $task_dto);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTask'
     *
     * @param  string $id The id of the task to be updated. (required)
     * @param  \StrehleDe\CamundaClient\Model\TaskDto $task_dto (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateTaskRequest($id, $task_dto = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling updateTask'
            );
        }

        $resourcePath = '/task/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($task_dto)) {
            $_tempBody = $task_dto;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($_tempBody));
            } else {
                $httpBody = $_tempBody;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
